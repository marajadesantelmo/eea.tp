---
title: "TP2"
output: html_document
---

# Trabajo Práctico Final | Enfoque Estadístico del Aprendizaje

Seteo inical

```{r echo=FALSE, warning=FALSE}
options(scipen = 99)
library(tidyverse)
library(eph) 
#devtools::install_github("Guidowe/occupationcross")
library(occupationcross)
library(GGally)
library(broom)
library(purrr)
library(stringr)
library(data.table)
library(pROC)
library(modelr)

```

## Preprocesamiento

Descargamos la Encuesta Permanente de Hogares utilizando el paquete ```eph```. Empezamos analizando el cuarto timestre del 2019.

``` {r}
#Descargamos la base
df <- get_microdata(year=2019, trimester=3, type='individual')
#La etiquetamos de forma automática con el comando del paquete eph
df <- organize_labels(df=df, type='individual')

#La guardo para no tener que estar bajándola todo el tiempo
saveRDS(df, 'EPH2019_3.Rds')
```

En este trabajo vamos a explicar la probabilidad de tener un trabajo precario según las siguientes predictoras: el género, el rango etario, la complejidad del puesto de trabajo (alta complejidad vs. media y baja), el sector productivo, el nivel educativo, la región, la cantidad de personas dependientes de cuidados en el hogar del empleado/a y la realización o no de teletrabajo. A continuación creamos las variables.

```{r echo=TRUE, warning=FALSE}

df <- readRDS('EPH2019_3.Rds')

df <- df %>% 

  select(ESTADO, CAT_OCUP, REGION, CH04, CH06, CH12, CH13, PP04D_COD, PP04B_COD, PP07H, #Nos quedamos con las variables que utlizaremos
         PP04C, PP04C99, PP04G, V5_M, DECCFR, CODUSU, NRO_HOGAR) 

#Generamos variable sobre complejidad del puesto de trabajo 'Baja', 'Media' o 'Alta', utilizando el paquete occupationcross 
df <- reclassify_to_isco08(base = df , variable = PP04D_COD, classif_origin = 'CNO2017', add_skill = T)

#La traducimos al español
df <- df %>%  
    mutate(complejidad= factor(case_when(skill_level=='Low' ~ 'Baja', 
                                  skill_level=='Medium' ~ 'Media',
                                  skill_level=='High' ~ 'Alta'), 
                              levels= c('Baja', 'Media', 'Alta')))
#Generamos otras variables
df <- df %>% 
        #Rango Etario
  mutate(rango_etario= factor(case_when(CH06 < 25 ~ 'Joven',  
                                 CH06 %in% 25:40 ~ 'Joven adulto', 
                                 CH06 %in% 41:59 ~ 'Adulto', 
                                 CH06 > 59 ~ 'Adulto mayor'),
                        levels= c('Joven', 'Joven adulto', 'Adulto', 'Adulto mayor')),
                        
        #Precariedad laboral (tomando como referencia realización de aportes jubilatorios)
          precariedad= factor(case_when(PP07H == 1 ~ "No precario",
                                        PP07H == 2 ~ "Precario"),
                        levels= c('No precario', 'Precario')),
        #Tamaño del establecimiento  
          tamanio= factor(case_when(PP04C %in% 1:6  |(PP04C %in% 99 & PP04C99 == 1)~ "Pequeño",
                             PP04C %in% 7:8  ~ "Mediano",
                             PP04C %in% 9:12 |(PP04C %in% 99 & PP04C99 == 3)~ "Grande"),
                        levels= c('Pequeño', 'Mediano', 'Grande')), 
        #Nivel educativo
          nivel_educativo= factor(case_when(CH12 %in% 1:3 ~ 'Primario', 
                                     CH12 %in% 4:6 & CH13==2 ~ 'Primario', 
                                     CH12 %in% 4:6 & CH13==1 ~ 'Secundario', 
                                     CH12 %in% 7:8 & CH13==2 ~ 'Secundario',
                                     CH12 %in% 7:8 & CH13==1 ~ 'Universitario'),
                        levels= c('Primario', 'Secundario', 'Universitario')),
        #Teletrabajo
          teletrabajo=factor(case_when(str_sub(PP04D_COD, start= 3, end =3) == 3 &
                                         (PP04G == 6)~ "teletrabajo",
                                          TRUE~"presencial")),
        #Sector
          sector = factor (case_when(str_sub(PP04B_COD, start = 1, end = 3) < 04 ~ "agro",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 04 &(str_sub(PP04B_COD, start = 1, end = 3) < 10) ~ "extractivo",
                                    str_sub(PP04B_COD, start = 1, end = 3)> 09 &(str_sub(PP04B_COD, start = 1, end = 3) < 35) ~ "industria_manuf",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 34 &(str_sub(PP04B_COD, start = 1, end = 3) < 40) ~ "ss_publico",
                                    str_sub(PP04B_COD, start = 1, end = 3) == 40 ~ "construcción",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 44 &(str_sub(PP04B_COD, start = 1, end = 3) < 54) ~ "comercio_y_transporte",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 44 &(str_sub(PP04B_COD, start = 1, end = 3) < 97) ~ "ss_personales_y_prof",
                                             TRUE ~ "ss_domestico_y_otros"),
                                    levels=c("agro", "extractivo", "industria_manuf",
                                             "ss_publico","construcción", "comercio_y_transporte",
                                             "ss_personales_y_prof", "ss_domestico_y_otros")),
        
      #Genero
        genero= factor(case_when(CH04== 1 ~ "hombre", TRUE~ "mujer"),
                                 levels= c("hombre", 'mujer')),
        
      #Region      
        region = factor(case_when(REGION == 01 ~ "Gran Buenos Aires",
                                  REGION == 40 ~ "NOA",
                                  REGION == 41 ~ "NEA",
                                  REGION == 42 ~ "Cuyo",
                                  REGION == 43 ~ "Pampeana",
                                  REGION == 44 ~ "Patagonia"),
                        levels= c("Gran Buenos Aires", 'NOA', 'NEA', "Cuyo", "Pampeana", "Patagonia")),
                                  
        ipcf = factor(case_when(DECCFR %in% 1:5  ~ "bajo",            ### VERIFICAR: Hice cambios en esta variable xq la catetgoría alta tenia 0 registros
                                DECCFR %in% 6:8  ~ "medio",
                                DECCFR %in% 9:10  ~ "alto"),
                      levels = c("bajo", "medio", "alto")), 


        subsidio = factor(case_when(V5_M == 0 ~ "no", TRUE~ "si"),
                          levels = c("no", "si")), 
        dependiente_cuidados= case_when(
                                  CH06 < 18 | CH06 > 75   ~ "Dependiente",    #Menores 18 y adultos mayores de 75
                                  TRUE       ~ "No dependiente")) %>% 
  
  group_by(CODUSU,NRO_HOGAR) %>% 
  
  mutate(qdependientes = sum(dependiente_cuidados=="Dependiente"), 
         dependientes= case_when(
           qdependientes>0 ~ "Hogar con dependientes",
           TRUE            ~ "Hogar sin dependientes")) %>% 
  
  ungroup()  %>%
  
  filter(ESTADO==1 & CAT_OCUP==3) %>%                                 #Filtramos a asalariados ocupados
          
  select(precariedad, genero, nivel_educativo, rango_etario, 
            sector, tamanio, complejidad, teletrabajo, subsidio, ipcf, dependientes) # Nos quedamos con las variables que entran para el modelo

```

Limpieza de missing values

``` {r}
#Chequeamos cuantas missings hay

na_count <-sapply(df, function(y) sum(length(which(is.na(y)))))
na_count <- data.frame(na_count)

#Nos quedamos con casos sin missings

df <- df[complete.cases(df), ]
```


## Analisis exploratorio de los datos

### Correlación entre variables

``` {r}
### Hice la prueba con el boxplot, pero no me convence mucho. También hice la prueba graficando en un plot de barras apiladas los porcentajes de casos en cada categoría. 

#Boxplot convirtiedo en numérica las categóricas que son ordinales

df %>% mutate(ipcf2=case_when(ipcf=="bajo"  ~ 1, 
                              ipcf=="medio" ~ 2, 
                              ipcf=="alto"  ~ 3)) %>% 
  ggplot(aes(x = precariedad , y =as.numeric(ipcf2))) + 
  geom_boxplot(aes(fill=precariedad))

##Grafico IPCF según precariedad
#Calculo los datos de porcentaje de casos
df %>% group_by(precariedad, ipcf) %>% 
  count() %>% 
  ungroup() %>% 
  group_by(precariedad) %>% 
  mutate(porc=n/sum(n)) %>% 
  ungroup() %>% 
  select(precariedad, ipcf, porc) %>% 
  ggplot(aes(x = precariedad , y=porc)) +     #Armo grafico de barras
  geom_bar(aes(fill=ipcf), stat="identity", position = "fill") +
  scale_fill_manual(values = c("#3D5B59","#B5E5CF","#FCB5AC"))+
  labs(y="Porcentaje",x="Precariedad")

```
``` {r}
##Grafico IPCF según precariedad
#Calculo los datos de porcentaje de casos
df %>% group_by(precariedad, complejidad) %>% 
  count() %>% 
  ungroup() %>% 
  group_by(precariedad) %>% 
  mutate(porc=n/sum(n)) %>% 
  ungroup() %>% 
  select(precariedad, complejidad, porc) %>% 
  ggplot(aes(x = precariedad , y=porc)) +     #Armo grafico de barras
  geom_bar(aes(fill=complejidad), stat="identity", position = "fill") +
  scale_fill_manual(values = c("#3D5B59","#B5E5CF","#FCB5AC"))+
  labs(y="Porcentaje",x="Precariedad")
```


Ahora pasemos a analizar la existencia de relaciones de dependencia entre las variables categóricas mediante el test chi cuadradod de Pearson. Para ello calculamos el test entre todas las variables y las presentamos en un dataframe

``` {r}

#Ordeno las variables alfabeticamente para no tener lio en el loop y que el vector de nombres coincida con el indice de posicion
df <- df %>% 
    select(sort(names(.)))

#Genero vector de variables para correr test sobre todas las columnas
variables <- ls(df)

#Genero data frame para hacer la matriz
chiMatriz <- as.data.frame(variables)

for (i in 1:length(variables)) { 
  
#Estimo test
CHIS <- lapply(df[,-i], function(x) chisq.test(df[,i], x))

#Guardo resultados (solo variables y p-value)
tabla_chi <- rbindlist(lapply(CHIS, tidy), idcol=TRUE) %>% 
  as.data.frame() %>% 
  select(.id, p.value) 

#Cambio nombre de columna por el de la variable de la iteración
colnames(tabla_chi)[2] <- variables[i]

#Lo guardo en la matriz
chiMatriz <- chiMatriz %>% 
  left_join(tabla_chi, by= c("variables"=".id"))
}

#Redondeo
chiMatriz[,-1] <-round(chiMatriz[,-1],4) 

print(chiMatriz)

```


partimos el dataset

```{r}
smp_size <- floor(0.75 * nrow(df))

set.seed(123)
train_ind <- sample(seq_len(nrow(df)), size = smp_size)

preca_train <- df[train_ind, ]
preca_test <- df[-train_ind, ]
```



ver clases
```{r}

train <- preca_train %>% 
  group_by(precariedad) %>% 
  summarise(numero_casos=n()) %>%
  mutate(prop = round(prop.table(numero_casos)*100,2))

test <- preca_test %>% 
  group_by(precariedad) %>% 
  summarise(numero_casos=n()) %>%
  mutate(prop = round(prop.table(numero_casos)*100,2))
# armamos tabla conjunta para graficar
distrib = cbind(rbind(train, test), dataset = c("train", "train", "test", "test"))
distrib


ggplot(distrib, aes(x = precariedad, y = prop, fill = factor(precariedad), label = prop)) + 
         geom_bar(stat="identity", position = "dodge") + facet_wrap(~ dataset) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Precarios", y = "Proporción en %", title = "Proporción de precarios por dataset") + 
  theme_bw() +
  scale_fill_brewer(palette="Set1")
```



## Modelo Logit

``` {r}
glm1 <- glm(data = preca_train, precariedad ~ genero + ipcf + nivel_educativo + rango_etario + sector+  tamanio + complejidad + subsidio + teletrabajo, family = 'binomial')

# veo los resultados
tidy(glm1)

#restulados del modelo
glance(glm1)

```

El modelo da con estimadores estadísticamente significativos. Ser Adulto o Joven adulto disminuye la probabilidad de tener empleo precario con respecto a a ser adulto mayor, la probabilidad de ser precario disminuye cuanto más grande es el establecimiento donde se trabaja y también la probialidad de ser precario aumenta si la complejidad del puesto es baja o media con resecto a complejidad alta.  



ARMAMOS DIFERENTES MODELOS

``` {r}

logit_formulas <- formulas(.response = ~ precariedad,
                           completo = ~ genero + ipcf + nivel_educativo + rango_etario + sector+  tamanio + complejidad + subsidio + teletrabajo,
                           genero = ~genero,
                           nivel_educativo = ~ nivel_educativo,
                           rango_etario = ~ rango_etario,
                           sector = ~ sector,
                           tamanio = ~ tamanio,
                           complejidad = ~ complejidad,
                           teletrabajo= ~ teletrabajo,
                           subsidio = ~ subsidio,
                           ipcf = ~ ipcf,
                           dependientes = ~ dependientes,
                           social = ~ genero + nivel_educativo + rango_etario,
                           productivo = ~ sector + tamanio + complejidad,
                           ingresos = ~ ipcf + subsidio)

      
#creación de modelos
                     
models <- tibble(logit_formulas) %>% # dataframe a partir del objeto formulas
  mutate(models = names(logit_formulas), # columna con los nombres de las formulas
         expression = paste(logit_formulas), # columna con las expresiones de las formulas
         mod = map(logit_formulas, ~glm(., family = 'binomial', data = preca_train)))


#datos de los modelos
models <- models %>% mutate(tidy = map(mod, tidy)) %>% #formato tidy
  unnest(tidy) #resultados de los modelos   #tarda bastante en correr!



models #tarda bastante en correr
```



EVALUACIÓN DE MODELOS
``` {r}
models <- models %>% 
  mutate(glance = map(mod,glance))
# Obtener las medidas de evaluacion de interes
models <- models %>% 
  unnest(glance) %>%
  # Calculamos la deviance explicada
  mutate(perc_explained_dev = 1-deviance/null.deviance) %>% 
  select(-c(models, df.null, AIC, BIC)) %>% 
  arrange(deviance)

models
                                    
```

GRÁFICOS DE EVALUACIÓN
``` {r}

#quise hacer un for para que haga un violin plot para cada modelo pero no me salio!

models <- models %>% 
  mutate(pred= map(mod, augment, type.predict = "response"))


varios <- c("completo","genero", "nivel_educativo", "rango_etario", "sector", "productivo", "ingresos","tamanio", "complejidad", "teletrabajo", "subsidio", "ipcf", "dependientes", "social")


for (i in varios){
  
  z <-  models$pred[[i]]
  print(ggplot(z, aes(x=precariedad, y=.fitted, group=precariedad, fill=factor(precariedad))) + geom_violin() +   theme_bw() +   guides(scale="none") +
  labs(title='Violin plot', subtitle= i, y='Predicted probability'))
}
  

########################## hasta acá llegué !!!  #####################



#elegir el mejor y el peor y aplicar el gráfico Hosmer_Lemeshow_plot
#para mostrar la diferencia


```

VER: qué categorías ponemos como base en cada variable predictora?? #sí! esto me quedó pendiente tb. prioricé avanzar con el código

``` {r}
#Genero predicciones

df$pred <- glm1$fitted.values



```


#Evaluación de modelos

## Violin plot

``` {r}
ggplot(df, aes(x=precariedad, y=pred, group=precariedad, fill=factor(precariedad))) + 
  geom_violin() +
  theme_bw() +
  guides(scale="none") +
  labs(title='Violin plot', subtitle='Modelo 1', y='Probabilidad predicha')
```

El modelo con todas las predictoras clasifica bien a los precarios, pero no es muy bueno para los no precarios.

## Gráfico de Hosmer-Lemeshow


``` {r}
#Funcion que dieron en la práctica del curso

Hosmer_Lemeshow_plot <- function(dataset, predicted_column, class_column, bins, positive_value, color='forestgreen', nudge_x=0, nudge_y=0.05){
  # Asignar los grupos a las observaciones de acuerdo a la probabilidad predicha
  dataset['group'] <- bin(dataset[predicted_column], nbins = bins, method = 'l', labels=c(1:bins))
  # Contar la cantidad de casos positivos por grupo
  positive_class <- dataset %>% filter(!!sym(class_column)==positive_value) %>% group_by(group) %>% count()
  # Obtener la media de las predicciones por grupo
  HL_df <- dataset %>% group_by(group) %>% summarise(pred=mean(!!sym(predicted_column)), count=n()) %>%
            inner_join(.,positive_class) %>%
            mutate(freq=n/count)
  # Gráfico 
  HM_plot <- ggplot(HL_df, aes(x=pred, y=freq)) + 
    geom_point(aes(size=n), color=color) +
    geom_text(aes(label=n),nudge_y = nudge_y)+
    geom_abline(slope = 1, intercept = 0, linetype='dashed') + 
    theme_bw() +
    labs(title='Hosmer-Lemeshow', size='Casos', x="Probabilidad Predicha", y="Frecuencia observada")
  return(HM_plot)
}

# Modelo completo
Hosmer_Lemeshow_plot(df, 'pred', 'precariedad', 10, 1) +
  labs(subtitle="Modelo1")
```


No lo puedo hacer funcionar VER

## Curva ROC

``` {r}

roc <- roc(response=df$precariedad, predictor=df$pred)

ggroc(roc, size=1) +                                           ### Aca podemos graficar varios modelos, ver como lo tienen en la practica
  geom_abline(slope = 1, intercept = 1, linetype='dashed') +
  theme_bw() + 
  labs(title='Curvas ROC', color='Modelo')

```

Este funciona bien. Ver después de graficar los distintos modelos que hagamos en un mismo gráfico como lo tienen en la práctica

## Punto de corte

``` {r}

### Modificar lo que viene a continuación



#Funcion tomada de la practica
prediction_metrics <- function(cutoff, predictions=prediction_full){
  tab <- predictions %>% 
    mutate(predicted_class = if_else(.fitted > cutoff, 1, 0),
           Survived = factor(Survived))
  confusionMatrix(table(tab$predicted_class, tab$Survived), positive = "1") %>%
    tidy() %>%
    select(term, estimate) %>%
    filter(term %in% c('accuracy', 'sensitivity', 'specificity', 'precision')) %>%
    mutate(cutoff = cutoff)
}

cutoffs = seq(0.05,0.95,0.01)
logit_pred = map_df(cutoffs, prediction_metrics) %>% 
  mutate(term = as.factor(term), estimate = round(estimate, 3))
ggplot(logit_pred, aes(cutoff,estimate, group=term, color=term)) + geom_line(size=1) +
  theme_bw() +
  labs(title= 'Accuracy, Sensitivity, Specificity y Precision', subtitle= 'Modelo completo', color="")



```
