---
title: "TP2"
output: html_document
---

# Trabajo Práctico Final | Enfoque Estadístico del Aprendizaje

Seteo inical

```{r, echo=FALSE, warning=FALSE}
options(scipen = 99)
library(tidyverse)
library(eph) 
#devtools::install_github("Guidowe/occupationcross")
library(occupationcross)
library(GGally)
library(broom)
library(purrr)
library(stringr)
library(data.table)
library(pROC)
library(modelr)

```

## Preprocesamiento

Descargamos la Encuesta Permanente de Hogares utilizando el paquete ```eph```. Empezamos analizando el cuarto timestre del 2019.

``` {r}
#Descargamos la base
df <- get_microdata(year=2019, trimester=3, type='individual')
#La etiquetamos de forma automática con el comando del paquete eph
df <- organize_labels(df=df, type='individual')

#La guardo para no tener que estar bajándola todo el tiempo
saveRDS(df, 'EPH2019_3.Rds')
```

En este trabajo vamos a explicar la probabilidad de tener un trabajo precario según las siguientes predictoras: el género, el rango etario, la complejidad del puesto de trabajo (alta complejidad vs. media y baja), el sector productivo en el que la persona está inserta (industrial vs. no industrial), el nivel educativo (universitario vs. resto), la región (GBA vs. resto del país), la cantidad de adultos en el hogar y la realización o no de teletrabajo (atributo a construir en base a la propuesta metodológica del CEPXXI - MDP). A continuación creamos las variables.

``` {r}

df <- readRDS('EPH2019_3.Rds')

df <- df %>% 

  select(ESTADO, CAT_OCUP, REGION, CH04, CH06, CH12, CH13, PP04D_COD, PP04B_COD, PP07H, #Nos quedamos con las variables que utlizaremos
         PP04C, PP04C99, PP04G, V5_M, DECCFR, CODUSU, NRO_HOGAR, PONDERA) 

#Generamos variable sobre complejidad del puesto de trabajo 'Baja', 'Media' o 'Alta', utilizando el paquete occupationcross 
df <- reclassify_to_isco08(base = df , variable = PP04D_COD, classif_origin = 'CNO2017', add_skill = T)

#La traducimos al español
df <- df %>%  
    mutate(complejidad= case_when(skill_level=='Low' ~ 'Baja', 
                                  skill_level=='Medium' ~ 'Media',
                                  skill_level=='High' ~ 'Alta'))
#Generamos otras variables
df <- df %>% 
        #Rango Etario
  mutate(rango_etario= factor(case_when(CH06 < 25 ~ 'Joven',  
                                 CH06 %in% 25:40 ~ 'Joven adulto', 
                                 CH06 %in% 41:59 ~ 'Adulto', 
                                 CH06 > 59 ~ 'Adulto mayor'),
                        levels= c('Joven', 'Joven adulto', 'Adulto', 'Adulto mayor')),
                        
        #Precariedad laboral (tomando como referencia realización de aportes jubilatorios)
          precariedad= factor(case_when(PP07H == 1 ~ "No precario",
                                        PP07H == 2 ~ "Precario"),
                        levels= c('No precario', 'Precario')),
        #Tamaño del establecimiento  
          tamanio= factor(case_when(PP04C %in% 1:6  |(PP04C %in% 99 & PP04C99 == 1)~ "Pequeño",
                             PP04C %in% 7:8  ~ "Mediano",
                             PP04C %in% 9:12 |(PP04C %in% 99 & PP04C99 == 3)~ "Grande"),
                        levels= c('Pequeño', 'Mediano', 'Grande')), 
        #Nivel educativo
          nivel_educativo= factor(case_when(CH12 %in% 1:3 ~ 'Primario', 
                                     CH12 %in% 4:6 & CH13==2 ~ 'Primario', 
                                     CH12 %in% 4:6 & CH13==1 ~ 'Secundario', 
                                     CH12 %in% 7:8 & CH13==2 ~ 'Secundario',
                                     CH12 %in% 7:8 & CH13==1 ~ 'Universitario'),
                        levels= c('Primario', 'Secundario', 'Universitario')),
  
          teletrabajo=factor(case_when(str_sub(PP04D_COD, start= 3, end =3) == 3 &
                                         (PP04G == 6)~ "teletrabajo",
                                          TRUE~"presencial")),
        
          sector = factor (case_when(str_sub(PP04B_COD, start = 1, end = 3) < 04 ~ "agro",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 04 &(str_sub(PP04B_COD, start = 1, end = 3) < 10) ~ "extractivo",
                                    str_sub(PP04B_COD, start = 1, end = 3)> 09 &(str_sub(PP04B_COD, start = 1, end = 3) < 35) ~ "industria_manuf",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 34 &(str_sub(PP04B_COD, start = 1, end = 3) < 40) ~ "ss_publico",
                                    str_sub(PP04B_COD, start = 1, end = 3) == 40 ~ "construcción",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 44 &(str_sub(PP04B_COD, start = 1, end = 3) < 54) ~ "comercio_y_transporte",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 44 &(str_sub(PP04B_COD, start = 1, end = 3) < 97) ~ "ss_personales_y_prof",
                                             TRUE ~ "ss_domestico_y_otros"),
                                    levels=c("agro", "extractivo", "industria_manuf",
                                             "ss_publico","construcción", "comercio_y_transporte",
                                             "ss_personales_y_prof", "ss_domestico_y_otros")),
        
        
        genero= factor(case_when(CH04== 1 ~ "hombre", TRUE~ "mujer"),
                                 levels= c("hombre", 'mujer')),
        
            
        region = factor(case_when(REGION == 01 ~ "Gran Buenos Aires",
                                  REGION == 40 ~ "NOA",
                                  REGION == 41 ~ "NEA",
                                  REGION == 42 ~ "Cuyo",
                                  REGION == 43 ~ "Pampeana",
                                  REGION == 44 ~ "Patagonia"),
                        levels= c("Gran Buenos Aires", 'NOA', 'NEA', "Cuyo", "Pampeana", "Patagonia")),
                                  
        
#        ipcf = factor(case_when(DECCFR > 0 &(DECCFR < 6)  ~ "1",
 #                               DECCFR > 5 &(DECCFR < 9)  ~ "2",
  #                              DECCFR > 8 &(DECCFR < 5)  ~ "3"),
   #                   levels = c("1", "2", "3")), 

        
        ipcf = factor(case_when(DECCFR > 0 &(DECCFR < 6)  ~ "bajo",
                                DECCFR > 5 &(DECCFR < 9)  ~ "medio",
                                DECCFR > 8 &(DECCFR < 5)  ~ "alto"),
                      levels = c("bajo", "medio", "alto")), 


        subsidio = factor(case_when(V5_M == 0 ~ "no", TRUE~ "si"),
                          levels = c("no", "si")), 
        dependiente_cuidados= case_when(
                                  CH06 < 18 | CH06 > 75   ~ "Dependiente",    #Menores 18 y adultos mayores de 75
                                  TRUE       ~ "No dependiente")) %>% 
  
  group_by(CODUSU,NRO_HOGAR) %>% 
  
  mutate(qdependientes = sum(dependiente_cuidados=="Dependiente"), 
         dependientes= case_when(
           qdependientes>0 ~ "Hogar con dependientes",
           TRUE            ~ "Hogar sin dependientes")) %>% 
  
  ungroup()  %>%
  
  filter(ESTADO==1 & CAT_OCUP==3) %>%                                 #Filtramos a asalariados ocupados
          
  select(precariedad, genero, nivel_educativo, rango_etario, 
            sector, tamanio, complejidad, teletrabajo, subsidio, ipcf, dependientes, PONDERA) # Nos quedamos con las variables que entran para el modelo





```

Limpieza de missing values

``` {r}
#Chequeamos cuantas missings hay

na_count <-sapply(df, function(y) sum(length(which(is.na(y)))))
na_count <- data.frame(na_count)

#Nos quedamos con casos sin missings

df <- df[complete.cases(df), ]
```

Aplicamos expansores
``` {r}
#df_expanded <- df[rep(row.names(df), df$PONDERA), 1:ncol(df)-1]

# tuve que mutear la linea anterior porque pedirle que calcule 14 modelos con 5 millones de filas cada uno me tiraba a la mierda el R. ver si hacer sampleo  o hablemos que tengo una alternativa

df_expanded <- df



```


## Analisis exploratorio de los datos

### Correlación entre variables

``` {r}


#Calculo chi2 entre precariedad y cada una de las variables predictoras
CHIS <- lapply(df_expanded[,-1], function(x) chisq.test(df_expanded[,1], x))
#Imprimo resultados
rbindlist(lapply(CHIS, tidy), idcol=TRUE)


#no me salió, pero una buena forma es mostrar con boxplot cada variable convirtiéndo en numérica donde las categóricas son ordinales

#ggplot(data = df_expanded, aes(x = precariedad , y =as.numeric(ipcf))) +   geom_boxplot(aes(fill=precariedad))



```
La hipótesis nula no se rechaza en ningún caso por lo que la variable explicada parece ser independiente de todo el resto.

``` {r}
#Genero vector de variables para correr test sobre todas las columnas
variables <- ls(df_chi)

#Genero lista en donde guardo las tablas con los chi2 para cada variable
chiList <- list()

#Con este loop voy guardando los chi2 en una lista
for (i in 1:length(variables)) { 
#Estimo test
CHIS <- lapply(df_chi[,-i], function(x) chisq.test(df_chi[,i], x))
#Imprimo resultados
tabla_chi <- rbindlist(lapply(CHIS, tidy), idcol=TRUE)
#Los guardo en una lista
chiList[[variables[i]]] <- tabla_chi
}

#Con la lista generada ahora se pueden ver todos los test, por ejemplo, para los test de la variable complejidad con cada una de las otras variables:
chiList#[["complejidad"]]


```


partimos el dataset

```{r}
smp_size <- floor(0.75 * nrow(df_expanded))

set.seed(123)
train_ind <- sample(seq_len(nrow(df_expanded)), size = smp_size)

preca_train <- df_expanded[train_ind, ]
preca_test <- df_expanded[-train_ind, ]
```



ver clases
```{r}

train <- preca_train %>% 
  group_by(precariedad) %>% 
  summarise(numero_casos=n()) %>%
  mutate(prop = round(prop.table(numero_casos)*100,2))

test <- preca_test %>% 
  group_by(precariedad) %>% 
  summarise(numero_casos=n()) %>%
  mutate(prop = round(prop.table(numero_casos)*100,2))
# armamos tabla conjunta para graficar
distrib = cbind(rbind(train, test), dataset = c("train", "train", "test", "test"))
distrib


ggplot(distrib, aes(x = precariedad, y = prop, fill = factor(precariedad), label = prop)) + 
         geom_bar(stat="identity", position = "dodge") + facet_wrap(~ dataset) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Precarios", y = "Proporción en %", title = "Proporción de precarios por dataset") + 
  theme_bw() +
  scale_fill_brewer(palette="Set1")
```



## Modelo Logit

``` {r}
glm1 <- glm(data = preca_train, precariedad ~ genero + ipcf + nivel_educativo + rango_etario + sector+  tamanio + complejidad + subsidio + teletrabajo, family = 'binomial')

# veo los resultados
tidy(glm1)

#restulados del modelo
glance(glm1)

```

El modelo da con estimadores estadísticamente significativos. Ser Adulto o Joven adulto disminuye la probabilidad de tener empleo precario con respecto a a ser adulto mayor, la probabilidad de ser precario disminuye cuanto más grande es el establecimiento donde se trabaja y también la probialidad de ser precario aumenta si la complejidad del puesto es baja o media con resecto a complejidad alta.  



ARMAMOS DIFERENTES MODELOS

``` {r}

logit_formulas <- formulas(.response = ~ precariedad,
                           completo = ~ genero + ipcf + nivel_educativo + rango_etario + sector+  tamanio + complejidad + subsidio + teletrabajo,
                           genero = ~genero,
                           nivel_educativo = ~ nivel_educativo,
                           rango_etario = ~ rango_etario,
                           sector = ~ sector,
                           tamanio = ~ tamanio,
                           complejidad = ~ complejidad,
                           teletrabajo= ~ teletrabajo,
                           subsidio = ~ subsidio,
                           ipcf = ~ ipcf,
                           dependientes = ~ dependientes,
                           social = ~ genero + nivel_educativo + rango_etario,
                           productivo = ~ sector + tamanio + complejidad,
                           ingresos = ~ ipcf + subsidio)

      
#creación de modelos
                     
models <- tibble(logit_formulas) %>% # dataframe a partir del objeto formulas
  mutate(models = names(logit_formulas), # columna con los nombres de las formulas
         expression = paste(logit_formulas), # columna con las expresiones de las formulas
         mod = map(logit_formulas, ~glm(., family = 'binomial', data = preca_train)))


#datos de los modelos
models <- models %>% mutate(tidy = map(mod, tidy)) %>% #formato tidy
  unnest(tidy) #resultados de los modelos   #tarda bastante en correr!



models #tarda bastante en correr
```



EVALUACIÓN DE MODELOS
``` {r}
models <- models %>% 
  mutate(glance = map(mod,glance))
# Obtener las medidas de evaluacion de interes
models <- models %>% 
  unnest(glance) %>%
  # Calculamos la deviance explicada
  mutate(perc_explained_dev = 1-deviance/null.deviance) %>% 
  select(-c(models, df.null, AIC, BIC)) %>% 
  arrange(deviance)

models
                                    
```

GRÁFICOS DE EVALUACIÓN
``` {r}

#quise hacer un for para que haga un violin plot para cada modelo pero no me salio!

models <- models %>% 
  mutate(pred= map(mod, augment, type.predict = "response"))


varios <- c("completo","genero", "nivel_educativo", "rango_etario", "sector", "productivo", "ingresos","tamanio", "complejidad", "teletrabajo", "subsidio", "ipcf", "dependientes", "social")


for (i in varios){
  
  z <-  models$pred[[i]]
  print(ggplot(z, aes(x=precariedad, y=.fitted, group=precariedad, fill=factor(precariedad))) + geom_violin() +   theme_bw() +   guides(scale="none") +
  labs(title='Violin plot', subtitle= i, y='Predicted probability'))
}
  

########################## hasta acá llegué !!!  #####################



#elegir el mejor y el peor y aplicar el gráfico Hosmer_Lemeshow_plot
#para mostrar la diferencia


```

VER: qué categorías ponemos como base en cada variable predictora?? #sí! esto me quedó pendiente tb. prioricé avanzar con el código

``` {r}
#Genero predicciones

df$pred <- glm1$fitted.values



```


#Evaluación de modelos

## Violin plot

``` {r}
ggplot(df, aes(x=precariedad, y=pred, group=precariedad, fill=factor(precariedad))) + 
  geom_violin() +
  theme_bw() +
  guides(scale="none") +
  labs(title='Violin plot', subtitle='Modelo 1', y='Probabilidad predicha')
```

El modelo con todas las predictoras clasifica bien a los precarios, pero no es muy bueno para los no precarios.

## Gráfico de Hosmer-Lemeshow


``` {r}
#Funcion que dieron en la práctica del curso

Hosmer_Lemeshow_plot <- function(dataset, predicted_column, class_column, bins, positive_value, color='forestgreen', nudge_x=0, nudge_y=0.05){
  # Asignar los grupos a las observaciones de acuerdo a la probabilidad predicha
  dataset['group'] <- bin(dataset[predicted_column], nbins = bins, method = 'l', labels=c(1:bins))
  # Contar la cantidad de casos positivos por grupo
  positive_class <- dataset %>% filter(!!sym(class_column)==positive_value) %>% group_by(group) %>% count()
  # Obtener la media de las predicciones por grupo
  HL_df <- dataset %>% group_by(group) %>% summarise(pred=mean(!!sym(predicted_column)), count=n()) %>%
            inner_join(.,positive_class) %>%
            mutate(freq=n/count)
  # Gráfico 
  HM_plot <- ggplot(HL_df, aes(x=pred, y=freq)) + 
    geom_point(aes(size=n), color=color) +
    geom_text(aes(label=n),nudge_y = nudge_y)+
    geom_abline(slope = 1, intercept = 0, linetype='dashed') + 
    theme_bw() +
    labs(title='Hosmer-Lemeshow', size='Casos', x="Probabilidad Predicha", y="Frecuencia observada")
  return(HM_plot)
}

# Modelo completo
Hosmer_Lemeshow_plot(df, 'pred', 'precariedad', 10, 1) +
  labs(subtitle="Modelo1")
```


No lo puedo hacer funcionar VER

## Curva ROC

``` {r}

roc <- roc(response=df$precariedad, predictor=df$pred)

ggroc(roc, size=1) +                                           ### Aca podemos graficar varios modelos, ver como lo tienen en la practica
  geom_abline(slope = 1, intercept = 1, linetype='dashed') +
  theme_bw() + 
  labs(title='Curvas ROC', color='Modelo')

```

Este funciona bien. Ver después de graficar los distintos modelos que hagamos en un mismo gráfico como lo tienen en la práctica

## Punto de corte

``` {r}

### Modificar lo que viene a continuación



#Funcion tomada de la practica
prediction_metrics <- function(cutoff, predictions=prediction_full){
  tab <- predictions %>% 
    mutate(predicted_class = if_else(.fitted > cutoff, 1, 0),
           Survived = factor(Survived))
  confusionMatrix(table(tab$predicted_class, tab$Survived), positive = "1") %>%
    tidy() %>%
    select(term, estimate) %>%
    filter(term %in% c('accuracy', 'sensitivity', 'specificity', 'precision')) %>%
    mutate(cutoff = cutoff)
}

cutoffs = seq(0.05,0.95,0.01)
logit_pred = map_df(cutoffs, prediction_metrics) %>% 
  mutate(term = as.factor(term), estimate = round(estimate, 3))
ggplot(logit_pred, aes(cutoff,estimate, group=term, color=term)) + geom_line(size=1) +
  theme_bw() +
  labs(title= 'Accuracy, Sensitivity, Specificity y Precision', subtitle= 'Modelo completo', color="")



```
