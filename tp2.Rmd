---
title: "TP2"
output: html_document
---

# Trabajo Práctico Final | Enfoque Estadístico del Aprendizaje

Seteo inical

```{r, echo=FALSE, warning=FALSE}
options(scipen = 99)
library(tidyverse)
library(eph) 
#devtools::install_github("Guidowe/occupationcross")
library(occupationcross)
library(GGally)
library(broom)
library(purrr)
library(stringr)
library(data.table)
library(pROC)

```

## Preprocesamiento

Descargamos la Encuesta Permanente de Hogares utilizando el paquete ```eph```. Empezamos analizando el cuarto timestre del 2019.

``` {r}
#Descargamos la base
df <- get_microdata(year=2019, trimester=3, type='individual')
#La etiquetamos de forma automática con el comando del paquete eph
df <- organize_labels(df=df, type='individual')

#La guardo para no tener que estar bajándola todo el tiempo
saveRDS(df, 'EPH2019_3.Rds')
```

En este trabajo vamos a explicar la probabilidad de tener un trabajo precario según las siguientes predictoras: el género, el rango etario, la complejidad del puesto de trabajo (alta complejidad vs. media y baja), el sector productivo en el que la persona está inserta (industrial vs. no industrial), el nivel educativo (universitario vs. resto), la región (GBA vs. resto del país), la cantidad de adultos en el hogar y la realización o no de teletrabajo (atributo a construir en base a la propuesta metodológica del CEPXXI - MDP). A continuación creamos las variables.

``` {r}

df <- readRDS('EPH2019_3.Rds')

df <- df %>% 
  filter(ESTADO==1 & CAT_OCUP==3) %>%                                 #Filtramos a asalariados ocupados
  select(REGION, CH04, CH06, CH12, CH13, PP04D_COD, PP04B_COD, PP07H, #Nos quedamos con las variables que utlizaremos
         PP04C, PP04C99, PP04G, V5_M, DECCFR,  PONDERA) 

#Generamos variable sobre complejidad del puesto de trabajo 'Baja', 'Media' o 'Alta', utilizando el paquete occupationcross 
df <- reclassify_to_isco08(base = df , variable = PP04D_COD, classif_origin = 'CNO2017', add_skill = T)

#La traducimos al español
df <- df %>%  
    mutate(complejidad= case_when(skill_level=='Low' ~ 'Baja', 
                                  skill_level=='Medium' ~ 'Media',
                                  skill_level=='High' ~ 'Alta'))
#Generamos otras variables
df <- df %>% 
        #Rango Etario
  mutate(rango_etario= factor(case_when(CH06 < 25 ~ 'Joven',  
                                 CH06 %in% 25:40 ~ 'Joven adulto', 
                                 CH06 %in% 41:59 ~ 'Adulto', 
                                 CH06 > 59 ~ 'Adulto mayor'),
                        levels= c('Joven', 'Joven adulto', 'Adulto', 'Adulto mayor')),
                        
        #Precariedad laboral (tomando como referencia realización de aportes jubilatorios)
          precariedad= factor(case_when(PP07H == 1 ~ "Precario",
                                        PP07H == 2 ~ "No precario"),
                        levels= c('No precario', 'Precario')),
        #Tamaño del establecimiento  
          tamanio= factor(case_when(PP04C %in% 1:6  |(PP04C %in% 99 & PP04C99 == 1)~ "Pequeño",
                             PP04C %in% 7:8  ~ "Mediano",
                             PP04C %in% 9:12 |(PP04C %in% 99 & PP04C99 == 3)~ "Grande"),
                        levels= c('Pequeño', 'Mediano', 'Grande')), 
        #Nivel educativo
          nivel_educativo= factor(case_when(CH12 %in% 1:3 ~ 'Primario', 
                                     CH12 %in% 4:6 & CH13==2 ~ 'Primario', 
                                     CH12 %in% 4:6 & CH13==1 ~ 'Secundario', 
                                     CH12 %in% 7:8 & CH13==2 ~ 'Secundario',
                                     CH12 %in% 7:8 & CH13==1 ~ 'Universitario'),
                        levels= c('Primario', 'Secundario', 'Universitario')),
  
          teletrabajo=factor(case_when(str_sub(PP04D_COD, start= 3, end =3) == 3 &
                                         (PP04G == 6)~ "teletrabajo",
                                          TRUE~"presencial")),
        
          sector = factor (case_when(str_sub(PP04B_COD, start = 1, end = 3) < 04 ~ "agro",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 04 &(str_sub(PP04B_COD, start = 1, end = 3) < 10) ~ "extractivo",
                                    str_sub(PP04B_COD, start = 1, end = 3)> 09 &(str_sub(PP04B_COD, start = 1, end = 3) < 35) ~ "industria_manuf",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 34 &(str_sub(PP04B_COD, start = 1, end = 3) < 40) ~ "ss_publico",
                                    str_sub(PP04B_COD, start = 1, end = 3) == 40 ~ "construcción",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 44 &(str_sub(PP04B_COD, start = 1, end = 3) < 54) ~ "comercio_y_transporte",
                                    str_sub(PP04B_COD, start = 1, end = 3) > 44 &(str_sub(PP04B_COD, start = 1, end = 3) < 97) ~ "ss_personales_y_prof",
                                             TRUE ~ "ss_domestico_y_otros"),
                                    levels=c("agro", "extractivo", "industria_manuf",
                                             "ss_publico","construcción", "comercio_y_transporte",
                                             "ss_personales_y_prof", "ss_domestico_y_otros")),
        
        
        genero= factor(case_when(CH04== 1 ~ "hombre", TRUE~ "mujer"),
                                 levels= c("hombre", 'mujer')),
        
            
        region = factor(case_when(REGION == 01 ~ "Gran Buenos Aires",
                                  REGION == 40 ~ "NOA",
                                  REGION == 41 ~ "NEA",
                                  REGION == 42 ~ "Cuyo",
                                  REGION == 43 ~ "Pampeana",
                                  REGION == 44 ~ "Patagonia"),
                        levels= c("Gran Buenos Aires", 'NOA', 'NEA', "Cuyo", "Pampeana", "Patagonia")),
                                  
        
        ipcf = factor(case_when(DECCFR > 0 &(DECCFR < 6)  ~ "bajo",
                                DECCFR > 5 &(DECCFR < 9)  ~ "medio",
                                DECCFR > 8 &(DECCFR < 5)  ~ "alto"),
                      levels = c("bajo", "medio", "alto")), 


        subsidio = factor(case_when(V5_M == 0 ~ "no", TRUE~ "si"),
                          levels = c("no", "si")))   %>%
          
      select(precariedad, genero, nivel_educativo, rango_etario, 
            sector, tamanio, complejidad, teletrabajo, subsidio, ipcf, PONDERA) # Nos quedamos con las variables que entran para el modelo


```

Limpieza de missing values

``` {r}
#Chequeamos cuantas missings hay

na_count <-sapply(df, function(y) sum(length(which(is.na(y)))))
na_count <- data.frame(na_count)

#Nos quedamos con casos sin missings

df <- df[complete.cases(df), ] 
```


## Analisis exploratorio de los datos

### Correlación entre variables

``` {r}

#Saco el ponderador
df_chi <- df %>% select(-PONDERA)

#Calculo chi2 entre precariedad y cada una de las variables predictoras
CHIS <- lapply(df_chi[,-1], function(x) chisq.test(df_chi[,1], x))
#Imprimo resultados
rbindlist(lapply(CHIS, tidy), idcol=TRUE)
```
La variable explicada parece ser independiente de todo el resto

``` {r}
#Genero vector de variables para correr test sobre todas las columnas
variables <- ls(df_chi)

#Genero lista en donde guardo las tablas con los chi2 para cada variable
chiList <- list()

#Con este loop voy guardando los chi2 en una lista
for (i in 1:length(variables)) { 
#Estimo test
CHIS <- lapply(df_chi[,-i], function(x) chisq.test(df_chi[,i], x))
#Imprimo resultados
tabla_chi <- rbindlist(lapply(CHIS, tidy), idcol=TRUE)
#Los guardo en una lista
chiList[[variables[i]]] <- tabla_chi
}

#Con la lista generada ahora se pueden ver todos los test, por ejemplo, para los test de la variable complejidad con cada una de las otras variables:
chiList[["complejidad"]]


```

## Modelo Logit

``` {r}
glm1 <- glm(data = df, precariedad ~ genero + ipcf + nivel_educativo + rango_etario + sector+  tamanio + complejidad + subsidio + teletrabajo, family = 'binomial')

# veo los resultados
tidy(glm1)

```

El modelo da con estimadores estadísticamente significativos. Ser Adulto o Joven adulto disminuye la probabilidad de tener empleo precario con respecto a a ser adulto mayor, la probabilidad de ser precario disminuye cuanto más grande es el establecimiento donde se trabaja y también la probialidad de ser precario aumenta si la complejidad del puesto es baja o media con resecto a complejidad alta.  

``` {r}
#Probamos usando el ponderador

glm2 <- glm(data = df, precariedad ~ genero + ipcf + nivel_educativo + rango_etario + sector+  tamanio + complejidad + subsidio + teletrabajo, family = 'binomial', weights = PONDERA)

# veo los resultados
tidy(glm2)

#VER! Da un warning de que los iteradores no convergen y después los beta dan cualquier valor

```

VER: qué categorías ponemos como base en cada variable predictora??

``` {r}
#Genero predicciones

df$pred <- glm1$fitted.values



```


#Evaluación de modelos

## Violin plot

``` {r}
ggplot(df, aes(x=precariedad, y=pred, group=precariedad, fill=factor(precariedad))) + 
  geom_violin() +
  theme_bw() +
  guides(scale="none") +
  labs(title='Violin plot', subtitle='Modelo 1', y='Probabilidad predicha')
```

El modelo con todas las predictoras clasifica bien a los precarios, pero no es muy bueno para los no precarios.

## Gráfico de Hosmer-Lemeshow


``` {r}
#Funcion que dieron en la práctica del curso

Hosmer_Lemeshow_plot <- function(dataset, predicted_column, class_column, bins, positive_value, color='forestgreen', nudge_x=0, nudge_y=0.05){
  # Asignar los grupos a las observaciones de acuerdo a la probabilidad predicha
  dataset['group'] <- bin(dataset[predicted_column], nbins = bins, method = 'l', labels=c(1:bins))
  # Contar la cantidad de casos positivos por grupo
  positive_class <- dataset %>% filter(!!sym(class_column)==positive_value) %>% group_by(group) %>% count()
  # Obtener la media de las predicciones por grupo
  HL_df <- dataset %>% group_by(group) %>% summarise(pred=mean(!!sym(predicted_column)), count=n()) %>%
            inner_join(.,positive_class) %>%
            mutate(freq=n/count)
  # Gráfico 
  HM_plot <- ggplot(HL_df, aes(x=pred, y=freq)) + 
    geom_point(aes(size=n), color=color) +
    geom_text(aes(label=n),nudge_y = nudge_y)+
    geom_abline(slope = 1, intercept = 0, linetype='dashed') + 
    theme_bw() +
    labs(title='Hosmer-Lemeshow', size='Casos', x="Probabilidad Predicha", y="Frecuencia observada")
  return(HM_plot)
}

# Modelo completo
Hosmer_Lemeshow_plot(df, 'pred', 'precariedad', 10, 1) +
  labs(subtitle="Modelo1")
```


No lo puedo hacer funcionar VER

## Curva ROC

``` {r}

roc <- roc(response=df$precariedad, predictor=df$pred)

ggroc(roc, size=1) +                                           ### Aca podemos graficar varios modelos, ver como lo tienen en la practica
  geom_abline(slope = 1, intercept = 1, linetype='dashed') +
  theme_bw() + 
  labs(title='Curvas ROC', color='Modelo')

```

Este funciona bien. Ver después de graficar los distintos modelos que hagamos en un mismo gráfico como lo tienen en la práctica

## Punto de corte

``` {r}

### Modificar lo que viene a continuación



#Funcion tomada de la practica
prediction_metrics <- function(cutoff, predictions=prediction_full){
  tab <- predictions %>% 
    mutate(predicted_class = if_else(.fitted > cutoff, 1, 0),
           Survived = factor(Survived))
  confusionMatrix(table(tab$predicted_class, tab$Survived), positive = "1") %>%
    tidy() %>%
    select(term, estimate) %>%
    filter(term %in% c('accuracy', 'sensitivity', 'specificity', 'precision')) %>%
    mutate(cutoff = cutoff)
}

cutoffs = seq(0.05,0.95,0.01)
logit_pred = map_df(cutoffs, prediction_metrics) %>% 
  mutate(term = as.factor(term), estimate = round(estimate, 3))
ggplot(logit_pred, aes(cutoff,estimate, group=term, color=term)) + geom_line(size=1) +
  theme_bw() +
  labs(title= 'Accuracy, Sensitivity, Specificity y Precision', subtitle= 'Modelo completo', color="")



```
